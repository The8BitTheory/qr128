; this writes the
; - timing patterns (horizontal and vertical).
;   starting at row and column 6 (zero-based), starting with dark
; - finder patterns (top left, top right, bottom left)
;   8 modules, starting with dark at the corners
; - alignment pattern (only version 2 and up)
;   5x5 modules. at size-9 pixels. (or rightmost col-8 pixels) (eg 28 for 37 wide) (both, horizontal and vertical)
; 
; format patterns are part of the xor-mask

write_patterns
  
!zone write_patterns

    jsr .set_location
    
    ;--------------------
    ; horizontal timing pattern
    ;--------------------
    ; add 6xsize to be in the row for writing the pattern
    ldy #6
    lda z_location
-   clc
    adc size
    sta z_location
    bcc +
    inc z_location+1
    
+   dey
    bne -
    
    ; write modules, starting with dark
    lda #z_location   ; setup for indsta
    sta $02b9
    
    ldy #0
-   ldx #0
    lda #1
    jsr k_indsta
    iny
    
    cpy size          ; size is always an odd number, we only need to check for completeness here.
    beq .do_vertical
    
    ldx #0
    lda #0
    jsr k_indsta
    iny
    jmp -
  

    ;------------------
    ; vertical timing pattern 
    ;------------------
.do_vertical
    ;walk to column 6, row 0
    jsr .set_location
    
    clc
    lda z_location
    adc #6
    sta z_location
    bcc +
    inc z_location+1
    
+   ldy #0
    sty z_counter1
-   ldy #0
    ldx #0
    lda #1
    jsr k_indsta
    ldy z_counter1
    iny
    
    cpy size
    beq .do_finder
    
    sty z_counter1      ; could do inc z_counter1 as well, but that takes 5 cycles (sty takes 3)
    jsr .inc_line
    
    ldy #0
    ldx #0
    lda #0
    jsr k_indsta
    inc z_counter1      ; now inc makes sense. 5 cycles over (3 and 2 and 3 for ldy iny sty)
    jsr .inc_line
    jmp -
    
    ;---------------
    ; Finder patterns
    ;---------------
    
.do_finder

    ;top-left
    jsr .set_location_minus_1

    jsr .do_finder_square

    ;bottom-left
    jsr .set_location_minus_1
    
    ;calculate starting position of bottom-left pattern (=matrixSize-7*size)
    ; subtracting 7 lines from end of matrix is faster than adding size-7 lines to the start of the matrix
    ; start by storing end address of matrix in z_location
    jsr .set_location_end
    
    ; now, subtract 7 lines from z_location
    lda z_location
    ldy #7
-   sec
    sbc size
    sta z_location
    bcs +
    dec z_location+1

+   dey
    bne -
    
    lda z_location
    sec
    sbc #1
    sta z_location
    bcs +
    dec z_location+1
        
+   jsr .do_finder_square
    
    
    ;top-right
    jsr .set_location_minus_1
    
    ;calculate starting position of top-right pattern(=matrixStart + size-7)
    lda z_location
    clc
    adc size
    sta z_location
    bcc +
    inc z_location+1
    
+   sec
    sbc #7
    sta z_location
    bcs +
    dec z_location+1
    
+   jsr .do_finder_square

    ; we're done. if contentlength > 17, draw the alignment pattern. else, return
    lda contentLength
    cmp #18
    bcs .do_alignment_pattern
    rts
    

    ;this prints the following pattern
    ;XXXXXXX
    ;X     X
    ;X XXX X
    ;X XXX X
    ;X XXX X
    ;X     X
    ;XXXXXXX
.do_finder_square
    jsr .do_finder_line_1
    jsr .do_finder_line_2
    jsr .do_finder_line_345
    jsr .do_finder_line_2
    jsr .inc_line
    jsr .do_finder_line_1
    
    rts
    
    
    ; first line
.do_finder_line_1
    ldy #7

-   ldx #0
    lda #1
    jsr k_indsta
    dey
    bne -
    
    rts
    
    ; second line
.do_finder_line_2
    jsr .inc_line
    ldy #7
-   ldx #0
    lda .modules_1000001-1,y
    jsr k_indsta
    dey
    bne -
    
    rts
    
    ; lines 3-5
.do_finder_line_345
    lda #3
    sta z_counter1
    
--  jsr .inc_line
    ldy #7
-   ldx #0
    lda .modules_1011101-1,y
    jsr k_indsta
    dey
    bne -
    
    dec z_counter1
    bne --
    
    rts
    
    
.do_alignment_pattern
    ; the alignment pattern is 5x5 and always at location 28x28 (size - 9)
    ; XXXXX
    ; X   X
    ; X X X
    ; X   X
    ; XXXXX
    
    jsr .set_location_end
    
    ; now, subtract 8 lines from z_location
    lda z_location
    ldy #8
-   sec
    sbc size
    sta z_location
    bcs +
    dec z_location+1

+   dey
    bne -
    
    ; finally, subtract 10 from z_location (usually 9, but we re-use another method)
    lda z_location
    sec
    sbc #10
    sta z_location
    bcs +
    dec z_location+1

+   jsr .do_alignment_line_1
    jsr .do_alignment_line_2
    jsr .do_alignment_line_3
    jsr .do_alignment_line_2
    jsr .inc_line
    jsr .do_alignment_line_1

    jmp .end
    
.do_alignment_line_1
    ldy #5

-   ldx #0
    lda #1
    jsr k_indsta
    dey
    bne -
    
    rts
    
.do_alignment_line_2
    jsr .inc_line
    ldy #5
-   ldx #0
    lda .modules_10001-1,y
    jsr k_indsta
    dey
    bne -
    
    rts

.do_alignment_line_3
    jsr .inc_line
    ldy #5
-   ldx #0
    lda .modules_10101-1,y
    jsr k_indsta
    dey
    bne -
    
    rts

.inc_line
    lda z_location
    clc
    adc size
    sta z_location
    bcc +
    inc z_location+1
    
+   rts


    ; put first memory position of matrix into z_location
.set_location
    lda #<data
    sta z_location
    lda #>data
    sta z_location+1
    rts

.set_location_minus_1
    jsr .set_location
    
    lda z_location
    sec
    sbc #1
    sta z_location
    bcs +
    dec z_location+1
    
+   rts

.set_location_end
    jsr .set_location
    
    lda z_location
    clc
    adc matrixSize
    sta z_location
    bcc +
    inc z_location+1
    
+   lda z_location+1
    clc
    adc matrixSize+1
    sta z_location+1
    
    rts
    
.end
    rts
  

; first value is always skipped. set to invalid value
.modules_1000001 !byte 1,0,0,0,0,0,1
.modules_1011101 !byte 1,0,1,1,1,0,1
.modules_10001   !byte 1,0,0,0,1
.modules_10101   !byte 1,0,1,0,1






