; this renders 1 module per petscii-character
; so, output is limited to nr of lines on screen (23 on vic20, 25 on all the other machines)
; that leaves the vic20 with version 1 codes and all others with version 2 codes
; z_location contains the pointer to read from
; z_location2 is the pointer to screen ram to write to
renderspr

!zone render
z_sprite_bit    = z_counter1
z_sprite_byte   = z_counter1+1
z_sprite_offset = z_counter2


    jsr set_location_to_data
    ldy #0                    ;y holds the column (reset to zero after eol is reached)
    jsr .reset_sprite_byte
 
    ; z_location3 is used for rendering sprites   
    clc
    lda #<data
    adc matrixSize
    sta z_location3
    lda #>data
    adc matrixSize+1
    sta z_location3+1
    
    lda #0
-   sta (z_location3),y
    dey
    bne -
        
.handle_col
    lda (z_location),y
    bit .m_64   ;is xor-bit set?
    bvc .write_value  ;branch if this bit is not xored
    
    pha
    and #1
    sta z_temp
    pla
    and m_maskbit
    bne +
    lda #0
    jmp ++
+   lda #1
++  eor z_temp
    
.write_value
    bit .m_one
    bne +   

    ldx #32             ; black module (prints space)
                        ; don't need to do anything for sprite here (as bits are 0 already)
    jmp ++

+   ldx #160            ; white module (prints inverse space)
    lda z_sprite_byte
    ora z_sprite_bit
    sta z_sprite_byte   ; collect module for sprite byte

++  lda z_sprite_bit    ; shift bit to the right
    clc
    lsr
    sta z_sprite_bit
    bcc +               ; sprite bit is not zero, carry flag not set (ie sprite byte not full)
    
    ; if sprite bit is zero (carry flag set), sprite byte is full
    jsr .write_sprite_byte
    jsr .reset_sprite_byte
    
+   txa
    sta (z_location2),y
    bne +

    ;move on
+   iny
    cpy size
    bne .handle_col
    
    ; finish line
    ;jsr .write_sprite_byte
    ldy #0
    jsr .inc_line2
    jsr inc_line
    cmp stream2module.m_endAddress
    beq .end
    jmp .handle_col

.end
    rts
    
    
.inc_line2
    lda z_location2
    clc
    adc rsDivisorOffset
    sta z_location2
    bcc +
    inc z_location2+1
    
+   jsr .write_sprite_byte
    rts

.reset_sprite_byte
    lda #0
    sta z_sprite_byte            ;used to collect the byte value for 8 modules each
    lda #%10000000
    sta z_sprite_bit            ;used to keep track of bit    
    rts

.write_sprite_byte
    lda z_sprite_byte
    sty z_temp
    ldy z_sprite_offset
    sta (z_location3),y
    inc z_sprite_offset
    ldy z_temp
    rts

.m_one        !byte 1
.m_64         !byte 64

